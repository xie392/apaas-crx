// // 这是一个后台脚本，用于拦截网络请求并替换JavaScript文件
// import JSZip from "jszip"

// import { saveChunkedFile } from "./utils/storage"

// // 存储已经设置的规则和文件信息
// interface AppState {
//   outputName: string
//   rules: {
//     js?: string
//     css?: string
//     worker?: string
//     other?: string[]
//   }
//   zipData?: Uint8Array
//   lastUpdated?: number
// }

// let appState: AppState = {
//   outputName: "",
//   rules: {}
// }

// // 初始化时从storage加载上一次的状态
// chrome.runtime.onInstalled.addListener(() => {
//   chrome.storage.local.get(["appState"], (result) => {
//     if (result.appState) {
//       appState = result.appState
//       console.log("Loaded previous state:", appState)

//       // 如果有之前的状态，重新应用规则
//       if (appState.outputName) {
//         updateRedirectRules()
//       }
//     }
//   })
// })

// // 保存应用状态
// function saveAppState() {
//   // 添加最后更新时间
//   appState.lastUpdated = Date.now()
//   chrome.storage.local.set({ appState }, () => {
//     console.log("App state saved")
//   })
// }

// // 更新规则函数
// function updateRedirectRules() {
//   if (!appState.outputName) return

//   // 清除所有动态规则
//   chrome.declarativeNetRequest.getDynamicRules((existingRules) => {
//     chrome.declarativeNetRequest.updateDynamicRules(
//       {
//         removeRuleIds: existingRules.map((rule) => rule.id),
//         addRules: []
//       },
//       () => {
//         if (chrome.runtime.lastError) {
//           console.error("Error clearing rules:", chrome.runtime.lastError)
//         } else {
//           console.log("All previous rules have been cleared.")
//           // 保存状态
//           saveAppState()
//         }
//       }
//     )
//   })
// }

// // 处理文件请求
// chrome.webRequest.onBeforeRequest.addListener(
//   (details) => {
//     const url = new URL(details.url)
//     const fileName = url.pathname.split("/").pop() || ""

//     // 检查是否是我们要处理的文件
//     if (
//       !appState.outputName ||
//       !(
//         fileName.endsWith(`${appState.outputName}.umd.js`) ||
//         fileName.endsWith(`${appState.outputName}.css`) ||
//         fileName.endsWith(`${appState.outputName}.umd.worker.js`)
//       )
//     ) {
//       return { cancel: false }
//     }

//     try {
//       // 从storage获取文件内容
//       const fileKey = `asset_${fileName}`
//       const result = await new Promise<{ [key: string]: any }>((resolve) => {
//         chrome.storage.local.get([fileKey], resolve)
//       })

//       if (result[fileKey]) {
//         console.log(`Redirecting ${fileName} to stored version`)
//         return { redirectUrl: result[fileKey] }
//       }
//     } catch (error) {
//       console.error(`Error handling request for ${fileName}:`, error)
//     }

//     return { cancel: false }
//   },
//   { urls: ["<all_urls>"] },
//   ["blocking"]
// )

// // 清理旧的存储数据
// async function clearPreviousStorage(): Promise<void> {
//   return new Promise((resolve, reject) => {
//     try {
//       // 获取所有存储的键
//       chrome.storage.local.get(null, (items) => {
//         if (chrome.runtime.lastError) {
//           reject(chrome.runtime.lastError)
//           return
//         }

//         // 找出所有asset_开头的键（文件资源）
//         const assetKeys = Object.keys(items).filter((key) =>
//           key.startsWith("asset_")
//         )

//         // 如果没有资源键，直接返回
//         if (assetKeys.length === 0) {
//           resolve()
//           return
//         }

//         // 删除所有资源键
//         chrome.storage.local.remove(assetKeys, () => {
//           if (chrome.runtime.lastError) {
//             reject(chrome.runtime.lastError)
//           } else {
//             console.log(`已清理 ${assetKeys.length} 个旧资源文件`)
//             resolve()
//           }
//         })
//       })
//     } catch (error) {
//       reject(error)
//     }
//   })
// }

// // 处理从popup页面上传的文件
// async function processUploadedFiles(
//   outputName: string,
//   filesToSave: Record<string, ArrayBuffer>,
//   otherFiles: string[],
//   zipData: number[],
//   progressCallback: (progress: {
//     step: string
//     percent: number
//     details?: string
//   }) => void
// ) {
//   try {
//     console.log("Starting file processing with outputName:", outputName)
//     console.log("Files to save:", Object.keys(filesToSave))
//     console.log("Other files:", otherFiles)

//     // 开始处理
//     progressCallback({ step: "开始", percent: 5, details: "开始处理文件..." })

//     // 清理旧的存储数据
//     progressCallback({ step: "清理", percent: 10, details: "清理旧数据..." })
//     await clearPreviousStorage()

//     // 保存状态
//     appState = {
//       outputName,
//       rules: {
//         js: Object.keys(filesToSave).find((f) => f.endsWith(".umd.js")),
//         css: Object.keys(filesToSave).find((f) => f.endsWith(".css")),
//         worker: Object.keys(filesToSave).find((f) =>
//           f.endsWith(".umd.worker.js")
//         ),
//         // 不再处理其他静态资源文件
//         other: []
//       }
//       // 不再保存整个zip数据
//     }

//     progressCallback({
//       step: "保存JS/CSS",
//       percent: 20,
//       details: "保存主要文件..."
//     })

//     // 保存需要重定向的文件到插件的assets目录
//     let fileCount = 0
//     const totalFiles = Object.keys(filesToSave).length

//     for (const [fileName, fileContent] of Object.entries(filesToSave)) {
//       console.log(`Processing file ${fileCount + 1}/${totalFiles}: ${fileName}`)
//       console.log(`File size: ${fileContent.byteLength} bytes`)

//       try {
//         await saveFileToAssets(fileName, fileContent)
//         console.log(`Successfully saved file: ${fileName}`)
//         fileCount++
//         progressCallback({
//           step: "保存文件",
//           percent: 20 + Math.floor((fileCount / totalFiles) * 70),
//           details: `保存文件 ${fileCount}/${totalFiles}: ${fileName}`
//         })
//       } catch (error) {
//         console.error(`Failed to save file ${fileName}:`, error)
//         throw error
//       }
//     }

//     // 不再处理其他静态资源文件

//     // 更新重定向规则
//     progressCallback({
//       step: "更新规则",
//       percent: 90,
//       details: "更新重定向规则..."
//     })
//     updateRedirectRules()

//     progressCallback({ step: "完成", percent: 100, details: "处理完成！" })
//     return { success: true, rules: appState.rules }
//   } catch (error) {
//     console.error("Error processing files:", error)
//     progressCallback({
//       step: "错误",
//       percent: 0,
//       details: `处理出错: ${error.message}`
//     })
//     return { success: false, error: error.message }
//   }
// }

// // 辅助函数：保存文件到assets目录
// async function saveFileToAssets(
//   fileName: string,
//   fileContent: ArrayBuffer
// ): Promise<void> {
//   // 验证输入
//   if (!fileName || !fileContent) {
//     throw new Error("Invalid file name or content")
//   }

//   console.log(`Saving file: ${fileName} (${fileContent.byteLength} bytes)`)

//   try {
//     // 将ArrayBuffer转换为Blob
//     const blob = new Blob([fileContent])
//     // 创建data URL
//     const dataUrl = await new Promise<string>((resolve, reject) => {
//       const reader = new FileReader()
//       reader.onload = () => resolve(reader.result as string)
//       reader.onerror = reject
//       reader.readAsDataURL(blob)
//     })

//     // 保存data URL到storage
//     const fileKey = `asset_${fileName}`
//     await new Promise<void>((resolve, reject) => {
//       chrome.storage.local.set({ [fileKey]: dataUrl }, () => {
//         if (chrome.runtime.lastError) {
//           reject(chrome.runtime.lastError)
//         } else {
//           console.log(`File saved as data URL: ${fileName}`)
//           resolve()
//         }
//       })
//     })
//   } catch (error) {
//     console.error(`Failed to save file ${fileName}:`, error)
//     throw error
//   }
// }

// // 监听来自popup的消息
// chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
//   console.log("Received message:", message)

//   if (message.action === "processFiles") {
//     // 创建进度更新函数
//     const progressCallback = (progress: any) => {
//       // 向popup发送进度更新
//       chrome.runtime.sendMessage({
//         action: "progressUpdate",
//         progress: progress
//       })
//     }

//     processUploadedFiles(
//       message.outputName,
//       message.filesToSave,
//       message.otherFiles || [],
//       message.zipData,
//       progressCallback
//     ).then(sendResponse)
//     return true // 表示将异步发送响应
//   }

//   if (message.action === "getActiveRules") {
//     sendResponse({ rules: appState.rules, lastUpdated: appState.lastUpdated })
//     return true
//   }

//   // 处理获取资源请求
//   if (message.action === "getResource") {
//     const fileName = message.fileName
//     const fileKey = `asset_${fileName}`

//     // 首先尝试获取文件元数据
//     chrome.storage.local.get([`${fileKey}_meta`], async (result) => {
//       if (result[`${fileKey}_meta`]) {
//         try {
//           // 文件是分块存储的，需要重新组装
//           const meta = result[`${fileKey}_meta`]
//           const { chunks, size } = meta

//           // 创建一个数组来存储所有的块
//           const chunkKeys = Array.from(
//             { length: chunks },
//             (_, i) => `${fileKey}_${i}`
//           )

//           // 获取所有块
//           chrome.storage.local.get(chunkKeys, async (chunksResult) => {
//             try {
//               // 重新组装数据
//               const dataUrlParts: string[] = []
//               let dataUrlPrefix = ""

//               for (let i = 0; i < chunks; i++) {
//                 const chunkDataUrl = chunksResult[`${fileKey}_${i}`]
//                 if (!chunkDataUrl) {
//                   throw new Error(`找不到文件块: ${i}`)
//                 }

//                 if (i === 0) {
//                   // 从第一个块获取前缀（例如：data:application/javascript;base64,）
//                   const prefixEndIndex = chunkDataUrl.indexOf(",")
//                   dataUrlPrefix = chunkDataUrl.substring(0, prefixEndIndex + 1)
//                   dataUrlParts.push(chunkDataUrl.substring(prefixEndIndex + 1))
//                 } else {
//                   // 对于其他块，只添加数据部分（不包括前缀）
//                   const prefixEndIndex = chunkDataUrl.indexOf(",")
//                   dataUrlParts.push(chunkDataUrl.substring(prefixEndIndex + 1))
//                 }
//               }

//               // 组合完整的数据URL
//               const completeDataUrl = dataUrlPrefix + dataUrlParts.join("")

//               sendResponse({
//                 exists: true,
//                 dataUrl: completeDataUrl
//               })
//             } catch (error) {
//               console.error("Error reassembling file chunks:", error)
//               sendResponse({ exists: false, error: error.message })
//             }
//           })
//         } catch (error) {
//           console.error("Error processing chunked file:", error)
//           sendResponse({ exists: false, error: error.message })
//         }
//       } else {
//         // 文件可能没有找到，或者使用了旧的存储方式
//         // 尝试直接获取文件（兼容旧版本）
//         chrome.storage.local.get([fileKey], (result) => {
//           if (result[fileKey]) {
//             sendResponse({
//               exists: true,
//               dataUrl: result[fileKey]
//             })
//           } else {
//             // 如果没有找到完全匹配的文件名，尝试检查是否有匹配的输出名
//             if (appState.outputName) {
//               const baseOutputName = appState.outputName

//               // 检查是否是我们要替换的JS、CSS或Worker文件
//               if (
//                 fileName.endsWith(`${baseOutputName}.umd.js`) ||
//                 fileName.endsWith(`${baseOutputName}.css`) ||
//                 fileName.endsWith(`${baseOutputName}.umd.worker.js`)
//               ) {
//                 // 检查对应的文件是否存在
//                 let matchedFileKey = ""

//                 if (
//                   fileName.endsWith(`${baseOutputName}.umd.js`) &&
//                   appState.rules.js
//                 ) {
//                   matchedFileKey = `asset_${appState.rules.js}`
//                 } else if (
//                   fileName.endsWith(`${baseOutputName}.css`) &&
//                   appState.rules.css
//                 ) {
//                   matchedFileKey = `asset_${appState.rules.css}`
//                 } else if (
//                   fileName.endsWith(`${baseOutputName}.umd.worker.js`) &&
//                   appState.rules.worker
//                 ) {
//                   matchedFileKey = `asset_${appState.rules.worker}`
//                 }

//                 if (matchedFileKey) {
//                   // 尝试获取匹配文件的元数据
//                   chrome.storage.local.get(
//                     [`${matchedFileKey}_meta`],
//                     (metaResult) => {
//                       if (metaResult[`${matchedFileKey}_meta`]) {
//                         // 告诉调用方需要查找分块文件
//                         sendResponse({
//                           exists: true,
//                           chunked: true,
//                           fileKey: matchedFileKey
//                         })
//                       } else {
//                         // 尝试旧方式获取
//                         chrome.storage.local.get([matchedFileKey], (result) => {
//                           if (result[matchedFileKey]) {
//                             sendResponse({
//                               exists: true,
//                               dataUrl: result[matchedFileKey]
//                             })
//                           } else {
//                             sendResponse({ exists: false })
//                           }
//                         })
//                       }
//                     }
//                   )
//                   return true
//                 }
//               }

//               // 不再处理static或public目录下的文件
//             }

//             sendResponse({ exists: false })
//           }
//         })
//       }
//     })

//     return true // 表示将异步发送响应
//   }
// })

// // 处理文件请求
// chrome.webRequest.onBeforeRequest.addListener(
//   async (details) => {
//     const url = new URL(details.url)
//     const fileName = url.pathname.split("/").pop() || ""

//     // 检查是否是我们要处理的文件
//     if (
//       !appState.outputName ||
//       !(
//         fileName.endsWith(`${appState.outputName}.umd.js`) ||
//         fileName.endsWith(`${appState.outputName}.css`) ||
//         fileName.endsWith(`${appState.outputName}.umd.worker.js`)
//       )
//     ) {
//       return { cancel: false }
//     }

//     try {
//       // 从storage获取文件内容
//       const fileKey = `asset_${fileName}`
//       const result = await new Promise((resolve) => {
//         chrome.storage.local.get([fileKey], resolve)
//       })

//       if (result[fileKey]) {
//         console.log(`Redirecting ${fileName} to stored version`)
//         return { redirectUrl: result[fileKey] }
//       }
//     } catch (error) {
//       console.error(`Error handling request for ${fileName}:`, error)
//     }

//     return { cancel: false }
//   },
//   { urls: ["<all_urls>"] },
//   ["blocking"]
// )

// // 配置匹配规则，使本地脚本可以被网页访问
// export const config = {
//   matches: ["http://gscrm-ycdl-fw-jsfw.yctp.yuchaiqas.com/*", "<all_urls>"]
// }
